package com.gestion.intervention.application.person.service;

import com.gestion.intervention.application.person.record.PersonDTO;
import com.gestion.intervention.application.person.record.request.LoginRequestDTO;
import com.gestion.intervention.application.person.record.response.LoginResponseDTO;
import com.gestion.intervention.domain.person.model.Person;
import com.gestion.intervention.domain.person.repository.PersonRepository;
// Import other repositories if needed for deletion checks
// import com.gestion.intervention.domain.panne.repository.PanneRepository;
// import com.gestion.intervention.domain.technicianinfo.repository.TechnicianInfoRepository;
// import com.gestion.intervention.domain.helpdeskinfo.repository.HelpDeskInfoRepository;

import com.gestion.intervention.domain.role.model.Role;
import com.gestion.intervention.domain.role.repository.RoleRepository;
import com.gestion.intervention.kernel.security.jwt.JwtService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate; // Added import
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class PersonServiceImpl implements PersonService {

    private final AuthenticationManager authenticationManager;
    private final PersonRepository personRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;
    private final RoleRepository roleRepository;
    // Inject other repositories if needed for deletion checks
    // private final PanneRepository panneRepository;
    // private final TechnicianInfoRepository technicianInfoRepository;
    // private final HelpDeskInfoRepository helpDeskInfoRepository;


    @Override
    @Transactional
    public PersonDTO createPerson(PersonDTO dto) {
        validatePersonUniqueness(dto.CIN(), dto.email(), dto.username(), dto.telephone(), null);
        validatePersonData(dto); // Basic data checks

        Person person = Person.builder()
                // Explicitly setting ID only makes sense if it's provided and valid externally, otherwise omit
                // .id(dto.id()) // Usually generated by the DB, remove if auto-generated UUID
                .CIN(dto.CIN())
                .nom(dto.nom())
                .prenom(dto.prenom())
                .email(dto.email())
                .username(dto.username())
                .password(passwordEncoder.encode(dto.password())) // Ensure password isn't null/empty via DTO validation
                .telephone(dto.telephone())
                .address(dto.address())
                .dateNaissance(dto.dateNaissance())
                .build();
        Person savedPerson = personRepository.save(person);
        return toDto(savedPerson);
    }

    @Override
    @Transactional(readOnly = true)
    public PersonDTO getPersonById(UUID id) {
        return personRepository.findById(id)
                .map(this::toDto)
                .orElseThrow(() -> new EntityNotFoundException("Person not found with id: " + id));
    }

    @Override
    @Transactional(readOnly = true)
    public List<PersonDTO> getAllPersons() {
        return personRepository.findAll().stream()
                .map(this::toDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public PersonDTO updatePerson(UUID id, PersonDTO dto) {
        Person person = personRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Person not found with id: " + id));

        // Check uniqueness only if potentially unique fields are being changed
        validatePersonUniqueness(dto.CIN(), null, null, dto.telephone(), id); // Check CIN and telephone, ignore email/username for this update method
        validatePersonData(dto); // Basic data checks for updated fields

        person.setCIN(dto.CIN());
        person.setNom(dto.nom());
        person.setPrenom(dto.prenom()); // Added prenom update
        person.setTelephone(dto.telephone());
        person.setAddress(dto.address());
        person.setDateNaissance(dto.dateNaissance());

        // IMPORTANT: This method intentionally DOES NOT update email, username, or password.
        // Create separate dedicated methods (e.g., changeEmail, changePassword) for security reasons.

        Person updatedPerson = personRepository.save(person);
        return toDto(updatedPerson);
    }


    // Example method for password change (recommended over including in general update)
    @Transactional
    public void changePassword(UUID id, String newPassword) {
        if (newPassword == null || newPassword.trim().isEmpty()) {
            throw new IllegalArgumentException("New password cannot be empty.");
        }
        Person person = personRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Person not found with id: " + id));
        person.setPassword(passwordEncoder.encode(newPassword));
        personRepository.save(person);
    }


    @Override
    @Transactional
    public void deletePerson(UUID id) {
        if (!personRepository.existsById(id)) {
            throw new EntityNotFoundException("Person not found with id: " + id);
        }
        // Optional: Check for associations before deleting
        // checkPersonAssociations(id);

        personRepository.deleteById(id);
    }

    @Override
    public LoginResponseDTO login(LoginRequestDTO dto) {
        Person dbPerson = (dto.usernameOrEmail().contains("@")) ? personRepository.findByEmail(dto.usernameOrEmail()).orElseThrow(() -> new RuntimeException("")) : personRepository.findByUsername(dto.usernameOrEmail()).orElseThrow(() -> new RuntimeException(""));

        Authentication authentication = authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(dbPerson.getUsername(), dto.password()));

        if (!authentication.isAuthenticated())
            throw new RuntimeException("Authentication failed user was not found");

        return new LoginResponseDTO(jwtService.generateAccessToken(dbPerson), jwtService.generateRefreshToken(dbPerson), dbPerson.getPrenom(), dbPerson.getNom(), dbPerson.getRoles().stream().map(r -> String.valueOf(r.getAuthority())).toList());
    }

    @Override
    @Transactional
    public LoginResponseDTO register(PersonDTO dto) {
        personRepository.findByEmail(dto.email()).ifPresent(existingUser -> {
            throw new RuntimeException("Email already registered: " + dto.email());
        });

        Role defaultRole = roleRepository.findAll().stream().filter(r -> r.getAuthority().equals("ROLE_EMPLOYEE")).findFirst()
                .orElseThrow(() -> new RuntimeException("Error: Default Role ROLE_EMPLOYEE not found. Ensure roles are seeded in the database."));

        Person newPerson = Person.builder()
                .CIN(dto.CIN())
                .nom(dto.nom())
                .prenom(dto.prenom())
                .email(dto.email())
                .username(dto.username())
                .password(passwordEncoder.encode(dto.password()))
                .telephone(dto.telephone())
                .address(dto.address())
                .dateNaissance(dto.dateNaissance())
                .roles(List.of(defaultRole))
                .build();

        Person savedPerson = personRepository.save(newPerson);

        String accessToken = jwtService.generateAccessToken(savedPerson);
        String refreshToken = jwtService.generateRefreshToken(savedPerson);

        return new LoginResponseDTO(
                accessToken,
                refreshToken,
                savedPerson.getPrenom(),
                savedPerson.getNom(),
                savedPerson.getRoles().stream().map(Role::getAuthority).collect(Collectors.toList())
        );
    }

    private void validatePersonUniqueness(String cin, String email, String username, String telephone, UUID idToExclude) {
        // Check CIN uniqueness
        if (cin != null && !cin.trim().isEmpty()) {
            Optional<Person> existingByCin = personRepository.findByCIN(cin);
            if (existingByCin.isPresent() && (idToExclude == null || !existingByCin.get().getId().equals(idToExclude))) {
                throw new IllegalArgumentException("A person with this CIN already exists: " + cin);
            }
        }

        // Check Email uniqueness (only if provided - might only be checked on create)
        if (email != null && !email.trim().isEmpty()) {
            Optional<Person> existingByEmail = personRepository.findByEmail(email);
            if (existingByEmail.isPresent() && (idToExclude == null || !existingByEmail.get().getId().equals(idToExclude))) {
                throw new IllegalArgumentException("A person with this email already exists: " + email);
            }
        }

        // Check Username uniqueness (only if provided - might only be checked on create)
        if (username != null && !username.trim().isEmpty()) {
            Optional<Person> existingByUsername = personRepository.findByUsername(username);
            if (existingByUsername.isPresent() && (idToExclude == null || !existingByUsername.get().getId().equals(idToExclude))) {
                throw new IllegalArgumentException("A person with this username already exists: " + username);
            }
        }

        // Check Telephone uniqueness (if required)
        if (telephone != null && !telephone.trim().isEmpty()) {
            Optional<Person> existingByTelephone = personRepository.findByTelephone(telephone);
            if (existingByTelephone.isPresent() && (idToExclude == null || !existingByTelephone.get().getId().equals(idToExclude))) {
                throw new IllegalArgumentException("A person with this telephone number already exists: " + telephone);
            }
        }
    }

    private void validatePersonData(PersonDTO dto) {
        // Basic non-null/empty checks (many can be done via DTO validation annotations)
        if (dto.nom() == null || dto.nom().trim().isEmpty()) {
            throw new IllegalArgumentException("Last name (nom) cannot be empty.");
        }
        if (dto.prenom() == null || dto.prenom().trim().isEmpty()) {
            throw new IllegalArgumentException("First name (prenom) cannot be empty.");
        }
        if (dto.email() == null || dto.email().trim().isEmpty()) { // Basic check, format via @Email
            throw new IllegalArgumentException("Email cannot be empty.");
        }
        if (dto.username() == null || dto.username().trim().isEmpty()) {
            throw new IllegalArgumentException("Username cannot be empty.");
        }
        // Add password check for create method specifically if not using DTO validation
        // if (isCreateOperation && (dto.password() == null || dto.password().trim().isEmpty())) {
        //    throw new IllegalArgumentException("Password cannot be empty during creation.");
        // }

        // Check date of birth validity
        if (dto.dateNaissance() != null && dto.dateNaissance().isAfter(LocalDate.now())) {
            throw new IllegalArgumentException("Date of birth cannot be in the future.");
        }
    }

    /*
    // Optional: Check associations before deleting a person
    private void checkPersonAssociations(UUID personId) {
        // Check if person is a reporter for any active pannes
        if (panneRepository.existsActiveByReporterId(personId)) { // Requires custom repository method
             throw new IllegalStateException("Cannot delete person with id: " + personId + " as they are the reporter for active pannes.");
        }
        // Check if person is linked via TechnicianInfo
        if (technicianInfoRepository.existsByPersonId(personId)) { // Requires custom repository method
             throw new IllegalStateException("Cannot delete person with id: " + personId + " as they have associated TechnicianInfo.");
        }
         // Check if person is linked via HelpDeskInfo
        if (helpDeskInfoRepository.existsByPersonId(personId)) { // Requires custom repository method
             throw new IllegalStateException("Cannot delete person with id: " + personId + " as they have associated HelpDeskInfo.");
        }
        // Add checks for active interventions assigned via TechnicianInfo if needed
    }
    */

    private PersonDTO toDto(Person person) {
        if (person == null) {
            return null;
        }
        return new PersonDTO(
                person.getId(),
                person.getCIN(),
                person.getNom(),
                person.getPrenom(),
                person.getEmail(),
                person.getUsername(),
                null, // NEVER return the encoded password in a DTO
                person.getTelephone(),
                person.getAddress(),
                person.getDateNaissance()
        );
    }
}